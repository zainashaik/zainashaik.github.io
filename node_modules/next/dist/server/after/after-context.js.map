{"version":3,"sources":["../../../src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task.catch((error) => this.reportTaskError(error)))\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) {\n      throw new InvariantError(\n        'Missing workUnitStore in AfterContext.addCallback'\n      )\n    }\n    this.workUnitStores.add(workUnitStore)\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await callback()\n      } catch (error) {\n        this.reportTaskError(error)\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      'An error occurred in a function passed to `unstable_after()`:',\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `unstable_after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","PromiseQueue","pause","after","task","isThenable","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","InvariantError","workUnitStore","workUnitAsyncStorage","getStore","add","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","bindSnapshot","Promise","resolve","runCallbacks","size","phase","workStore","workAsyncStorage","withExecuteRevalidates","start","onIdle","console","handlerError","cause"],"mappings":"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"}