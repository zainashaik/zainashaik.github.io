{"version":3,"sources":["../../../src/server/request/connection.ts"],"sourcesContent":["import { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\n\n/**\n * This function allows you to indicate that you require an actual user Request before continuing.\n *\n * During prerendering it will never resolve and during rendering it resolves immediately.\n */\nexport function connection(): Promise<void> {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      return Promise.resolve(undefined)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      } else if (workUnitStore.phase === 'after') {\n        throw new Error(\n          `Route ${workStore.route} used \"connection\" inside \"unstable_after(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \"unstable_after(...)\" executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/unstable_after`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We return a promise that never resolves to allow the prender to stall at this point\n        return makeHangingPromise(workUnitStore.renderSignal, '`connection()`')\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We use React's postpone API to interrupt rendering here to create a dynamic hole\n        postponeWithTracking(\n          workStore.route,\n          'connection',\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We throw an error here to interrupt prerendering to mark the route as dynamic\n        throwToInterruptStaticGeneration('connection', workStore, workUnitStore)\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using headers inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  return Promise.resolve(undefined)\n}\n"],"names":["connection","workStore","workAsyncStorage","getStore","workUnitStore","workUnitAsyncStorage","forceStatic","Promise","resolve","undefined","type","Error","route","phase","dynamicShouldError","StaticGenBailoutError","makeHangingPromise","renderSignal","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender"],"mappings":";;;;+BAegBA;;;eAAAA;;;0CAfiB;8CACI;kCAK9B;yCAC+B;uCACH;AAO5B,SAASA;IACd,MAAMC,YAAYC,0CAAgB,CAACC,QAAQ;IAC3C,MAAMC,gBAAgBC,kDAAoB,CAACF,QAAQ;IAEnD,IAAIF,WAAW;QACb,IAAIA,UAAUK,WAAW,EAAE;YACzB,qFAAqF;YACrF,kCAAkC;YAClC,OAAOC,QAAQC,OAAO,CAACC;QACzB;QAEA,IAAIL,eAAe;YACjB,IAAIA,cAAcM,IAAI,KAAK,SAAS;gBAClC,MAAM,IAAIC,MACR,CAAC,MAAM,EAAEV,UAAUW,KAAK,CAAC,iVAAiV,CAAC;YAE/W,OAAO,IAAIR,cAAcM,IAAI,KAAK,kBAAkB;gBAClD,MAAM,IAAIC,MACR,CAAC,MAAM,EAAEV,UAAUW,KAAK,CAAC,0XAA0X,CAAC;YAExZ,OAAO,IAAIR,cAAcS,KAAK,KAAK,SAAS;gBAC1C,MAAM,IAAIF,MACR,CAAC,MAAM,EAAEV,UAAUW,KAAK,CAAC,wWAAwW,CAAC;YAEtY;QACF;QACA,IAAIX,UAAUa,kBAAkB,EAAE;YAChC,MAAM,IAAIC,8CAAqB,CAC7B,CAAC,MAAM,EAAEd,UAAUW,KAAK,CAAC,oNAAoN,CAAC;QAElP;QAEA,IAAIR,eAAe;YACjB,IAAIA,cAAcM,IAAI,KAAK,aAAa;gBACtC,sBAAsB;gBACtB,sFAAsF;gBACtF,OAAOM,IAAAA,yCAAkB,EAACZ,cAAca,YAAY,EAAE;YACxD,OAAO,IAAIb,cAAcM,IAAI,KAAK,iBAAiB;gBACjD,+BAA+B;gBAC/B,mFAAmF;gBACnFQ,IAAAA,sCAAoB,EAClBjB,UAAUW,KAAK,EACf,cACAR,cAAce,eAAe;YAEjC,OAAO,IAAIf,cAAcM,IAAI,KAAK,oBAAoB;gBACpD,mBAAmB;gBACnB,gFAAgF;gBAChFU,IAAAA,kDAAgC,EAAC,cAAcnB,WAAWG;YAC5D;QACF;QACA,iFAAiF;QACjF,yFAAyF;QACzFiB,IAAAA,iDAA+B,EAACpB,WAAWG;IAC7C;IAEA,OAAOG,QAAQC,OAAO,CAACC;AACzB"}