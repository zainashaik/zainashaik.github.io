{"version":3,"sources":["../../../src/server/resume-data-cache/cache-store.ts"],"sourcesContent":["import {\n  arrayBufferToString,\n  stringToUint8Array,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CachedFetchValue } from '../response-cache/types'\n\n/**\n * A generic cache store type that provides a subset of Map functionality\n */\ntype CacheStore<T> = Pick<Map<string, T>, 'entries' | 'size' | 'get' | 'set'>\n\n/**\n * A cache store specifically for fetch cache values\n */\nexport type FetchCacheStore = CacheStore<CachedFetchValue>\n\n/**\n * Parses fetch cache entries into a FetchCacheStore\n * @param entries - The entries to parse into the store\n * @returns A new FetchCacheStore containing the entries\n */\nexport function parseFetchCacheStore(\n  entries: Iterable<[string, CachedFetchValue]>\n): FetchCacheStore {\n  return new Map(entries)\n}\n\n/**\n * Stringifies a FetchCacheStore into an array of key-value pairs\n * @param store - The store to stringify\n * @returns A promise that resolves to an array of key-value pairs\n */\nexport function stringifyFetchCacheStore(\n  entries: IterableIterator<[string, CachedFetchValue]>\n): [string, CachedFetchValue][] {\n  return Array.from(entries)\n}\n\n/**\n * Serialized format for cache entries\n */\ninterface CacheCacheStoreSerialized {\n  value: string\n  tags: string[]\n  stale: number\n  timestamp: number\n  expire: number\n  revalidate: number\n}\n\n/**\n * A cache store specifically for \"use cache\" values that stores promises of\n * cache entries.\n */\nexport type UseCacheCacheStore = Pick<\n  Map<string, Promise<CacheEntry>>,\n  'entries' | 'size' | 'get' | 'set'\n>\n\n/**\n * Parses serialized cache entries into a UseCacheCacheStore\n * @param entries - The serialized entries to parse\n * @returns A new UseCacheCacheStore containing the parsed entries\n */\nexport function parseUseCacheCacheStore(\n  entries: Iterable<[string, CacheCacheStoreSerialized]>\n): UseCacheCacheStore {\n  const store = new Map<string, Promise<CacheEntry>>()\n\n  for (const [\n    key,\n    { value, tags, stale, timestamp, expire, revalidate },\n  ] of entries) {\n    store.set(\n      key,\n      Promise.resolve({\n        // Create a ReadableStream from the Uint8Array\n        value: new ReadableStream<Uint8Array>({\n          start(controller) {\n            // Enqueue the Uint8Array to the stream\n            controller.enqueue(stringToUint8Array(atob(value)))\n\n            // Close the stream\n            controller.close()\n          },\n        }),\n        tags,\n        stale,\n        timestamp,\n        expire,\n        revalidate,\n      })\n    )\n  }\n\n  return store\n}\n\n/**\n * Stringifies a UseCacheCacheStore into an array of key-value pairs\n * @param store - The store to stringify\n * @returns A promise that resolves to an array of key-value pairs with serialized values\n */\nexport async function stringifyUseCacheCacheStore(\n  entries: IterableIterator<[string, Promise<CacheEntry>]>\n): Promise<[string, CacheCacheStoreSerialized][]> {\n  return Promise.all(\n    Array.from(entries).map(([key, value]) => {\n      return value.then(async (entry) => {\n        const [left, right] = entry.value.tee()\n        entry.value = right\n\n        let binaryString: string = ''\n\n        // We want to encode the value as a string, but we aren't sure if the\n        // value is a a stream of UTF-8 bytes or not, so let's just encode it\n        // as a string using base64.\n        for await (const chunk of left) {\n          binaryString += arrayBufferToString(chunk)\n        }\n\n        return [\n          key,\n          {\n            // Encode the value as a base64 string.\n            value: btoa(binaryString),\n            tags: entry.tags,\n            stale: entry.stale,\n            timestamp: entry.timestamp,\n            expire: entry.expire,\n            revalidate: entry.revalidate,\n          },\n        ] as [string, CacheCacheStoreSerialized]\n      })\n    })\n  )\n}\n"],"names":["parseFetchCacheStore","parseUseCacheCacheStore","stringifyFetchCacheStore","stringifyUseCacheCacheStore","entries","Map","Array","from","store","key","value","tags","stale","timestamp","expire","revalidate","set","Promise","resolve","ReadableStream","start","controller","enqueue","stringToUint8Array","atob","close","all","map","then","entry","left","right","tee","binaryString","chunk","arrayBufferToString","btoa"],"mappings":";;;;;;;;;;;;;;;;;IAsBgBA,oBAAoB;eAApBA;;IA2CAC,uBAAuB;eAAvBA;;IAhCAC,wBAAwB;eAAxBA;;IAuEMC,2BAA2B;eAA3BA;;;iCArGf;AAmBA,SAASH,qBACdI,OAA6C;IAE7C,OAAO,IAAIC,IAAID;AACjB;AAOO,SAASF,yBACdE,OAAqD;IAErD,OAAOE,MAAMC,IAAI,CAACH;AACpB;AA4BO,SAASH,wBACdG,OAAsD;IAEtD,MAAMI,QAAQ,IAAIH;IAElB,KAAK,MAAM,CACTI,KACA,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,UAAU,EAAE,CACtD,IAAIX,QAAS;QACZI,MAAMQ,GAAG,CACPP,KACAQ,QAAQC,OAAO,CAAC;YACd,8CAA8C;YAC9CR,OAAO,IAAIS,eAA2B;gBACpCC,OAAMC,UAAU;oBACd,uCAAuC;oBACvCA,WAAWC,OAAO,CAACC,IAAAA,mCAAkB,EAACC,KAAKd;oBAE3C,mBAAmB;oBACnBW,WAAWI,KAAK;gBAClB;YACF;YACAd;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,OAAOP;AACT;AAOO,eAAeL,4BACpBC,OAAwD;IAExD,OAAOa,QAAQS,GAAG,CAChBpB,MAAMC,IAAI,CAACH,SAASuB,GAAG,CAAC,CAAC,CAAClB,KAAKC,MAAM;QACnC,OAAOA,MAAMkB,IAAI,CAAC,OAAOC;YACvB,MAAM,CAACC,MAAMC,MAAM,GAAGF,MAAMnB,KAAK,CAACsB,GAAG;YACrCH,MAAMnB,KAAK,GAAGqB;YAEd,IAAIE,eAAuB;YAE3B,qEAAqE;YACrE,qEAAqE;YACrE,4BAA4B;YAC5B,WAAW,MAAMC,SAASJ,KAAM;gBAC9BG,gBAAgBE,IAAAA,oCAAmB,EAACD;YACtC;YAEA,OAAO;gBACLzB;gBACA;oBACE,uCAAuC;oBACvCC,OAAO0B,KAAKH;oBACZtB,MAAMkB,MAAMlB,IAAI;oBAChBC,OAAOiB,MAAMjB,KAAK;oBAClBC,WAAWgB,MAAMhB,SAAS;oBAC1BC,QAAQe,MAAMf,MAAM;oBACpBC,YAAYc,MAAMd,UAAU;gBAC9B;aACD;QACH;IACF;AAEJ"}