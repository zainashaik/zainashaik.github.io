{"version":3,"sources":["../../src/server/patch-error-inspect.ts"],"sourcesContent":["import { findSourceMap, type SourceMapPayload } from 'module'\nimport * as path from 'path'\nimport * as url from 'url'\nimport type * as util from 'util'\nimport { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map'\nimport type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport { parseStack } from '../client/components/react-dev-overlay/server/middleware'\nimport { getOriginalCodeFrame } from '../client/components/react-dev-overlay/server/shared'\nimport { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external'\n\ninterface ModernRawSourceMap extends SourceMapPayload {\n  ignoreList?: number[]\n}\n\ninterface IgnoreableStackFrame extends StackFrame {\n  ignored: boolean\n}\n\ntype SourceMapCache = Map<\n  string,\n  { map: SyncSourceMapConsumer; raw: ModernRawSourceMap }\n>\n\n// TODO: Implement for Edge runtime\nconst inspectSymbol = Symbol.for('nodejs.util.inspect.custom')\n\nfunction frameToString(frame: StackFrame): string {\n  let sourceLocation = frame.lineNumber !== null ? `:${frame.lineNumber}` : ''\n  if (frame.column !== null && sourceLocation !== '') {\n    sourceLocation += `:${frame.column}`\n  }\n\n  const filePath =\n    frame.file !== null &&\n    frame.file.startsWith('file://') &&\n    URL.canParse(frame.file)\n      ? // If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.\n        // In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.\n        // There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted\n        // since relative to cwd is both the shortest and snappiest.\n        path.relative(process.cwd(), url.fileURLToPath(frame.file))\n      : frame.file\n\n  return frame.methodName\n    ? `    at ${frame.methodName} (${filePath}${sourceLocation})`\n    : `    at ${filePath}${frame.lineNumber}:${frame.column}`\n}\n\nfunction computeErrorName(error: Error): string {\n  // TODO: Node.js seems to use a different algorithm\n  // class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`\n  // in the stack i.e. seems like under certain conditions it favors the constructor name.\n  return error.name || 'Error'\n}\n\nfunction prepareUnsourcemappedStackTrace(\n  error: Error,\n  structuredStackTrace: any[]\n): string {\n  const name = computeErrorName(error)\n  const message = error.message || ''\n  let stack = name + ': ' + message\n  for (let i = 0; i < structuredStackTrace.length; i++) {\n    stack += '\\n    at ' + structuredStackTrace[i].toString()\n  }\n  return stack\n}\n\nfunction shouldIgnoreListByDefault(file: string): boolean {\n  return file.startsWith('node:')\n}\n\nfunction getSourcemappedFrameIfPossible(\n  frame: StackFrame,\n  sourceMapCache: SourceMapCache\n): {\n  stack: IgnoreableStackFrame\n  // DEV only\n  code: string | null\n} | null {\n  if (frame.file === null) {\n    return null\n  }\n\n  const sourceMapCacheEntry = sourceMapCache.get(frame.file)\n  let sourceMap: SyncSourceMapConsumer\n  let rawSourceMap: ModernRawSourceMap\n  if (sourceMapCacheEntry === undefined) {\n    const moduleSourceMap = findSourceMap(frame.file)\n    if (moduleSourceMap === undefined) {\n      return null\n    }\n    rawSourceMap = moduleSourceMap.payload\n    sourceMap = new SyncSourceMapConsumer(\n      // @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string\n      rawSourceMap\n    )\n    sourceMapCache.set(frame.file, {\n      map: sourceMap,\n      raw: rawSourceMap,\n    })\n  } else {\n    sourceMap = sourceMapCacheEntry.map\n    rawSourceMap = sourceMapCacheEntry.raw\n  }\n\n  const sourcePosition = sourceMap.originalPositionFor({\n    column: frame.column ?? 0,\n    line: frame.lineNumber ?? 1,\n  })\n\n  if (sourcePosition.source === null) {\n    return null\n  }\n\n  const sourceContent: string | null =\n    sourceMap.sourceContentFor(\n      sourcePosition.source,\n      /* returnNullOnMissing */ true\n    ) ?? null\n\n  // TODO: O(n^2). Consider moving `ignoreList` into a Set\n  const sourceIndex = rawSourceMap.sources.indexOf(sourcePosition.source)\n  const ignored = rawSourceMap.ignoreList?.includes(sourceIndex) ?? false\n\n  const originalFrame: IgnoreableStackFrame = {\n    methodName:\n      sourcePosition.name ||\n      // default is not a valid identifier in JS so webpack uses a custom variable when it's an unnamed default export\n      // Resolve it back to `default` for the method name if the source position didn't have the method.\n      frame.methodName\n        ?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')\n        ?.replace('__webpack_exports__.', ''),\n    column: sourcePosition.column,\n    file: sourcePosition.source,\n    lineNumber: sourcePosition.line,\n    // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n    arguments: [],\n    ignored,\n  }\n\n  const codeFrame =\n    process.env.NODE_ENV !== 'production'\n      ? getOriginalCodeFrame(originalFrame, sourceContent)\n      : null\n\n  return {\n    stack: originalFrame,\n    code: codeFrame,\n  }\n}\n\nfunction parseAndSourceMap(error: Error): string {\n  // We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.\n  let unparsedStack = String(error.stack)\n  // We could just read it from `error.stack`.\n  // This works around cases where a 3rd party `Error.prepareStackTrace` implementation\n  // doesn't implement the name computation correctly.\n  const errorName = computeErrorName(error)\n\n  let idx = unparsedStack.indexOf('react-stack-bottom-frame')\n  if (idx !== -1) {\n    idx = unparsedStack.lastIndexOf('\\n', idx)\n  }\n  if (idx !== -1) {\n    // Cut off everything after the bottom frame since it'll be React internals.\n    unparsedStack = unparsedStack.slice(0, idx)\n  }\n\n  const unsourcemappedStack = parseStack(unparsedStack)\n  const sourceMapCache: SourceMapCache = new Map()\n\n  let sourceMappedStack = ''\n  let sourceFrameDEV: null | string = null\n  for (const frame of unsourcemappedStack) {\n    if (frame.file === null) {\n      sourceMappedStack += '\\n' + frameToString(frame)\n    } else if (!shouldIgnoreListByDefault(frame.file)) {\n      const sourcemappedFrame = getSourcemappedFrameIfPossible(\n        frame,\n        sourceMapCache\n      )\n\n      if (sourcemappedFrame === null) {\n        sourceMappedStack += '\\n' + frameToString(frame)\n      } else {\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          sourcemappedFrame.code !== null &&\n          sourceFrameDEV === null &&\n          // TODO: Is this the right choice?\n          !sourcemappedFrame.stack.ignored\n        ) {\n          sourceFrameDEV = sourcemappedFrame.code\n        }\n        if (!sourcemappedFrame.stack.ignored) {\n          // TODO: Consider what happens if every frame is ignore listed.\n          sourceMappedStack += '\\n' + frameToString(sourcemappedFrame.stack)\n        }\n      }\n    }\n  }\n\n  return (\n    errorName +\n    ': ' +\n    error.message +\n    sourceMappedStack +\n    (sourceFrameDEV !== null ? '\\n' + sourceFrameDEV : '')\n  )\n}\n\nexport function patchErrorInspect() {\n  Error.prepareStackTrace = prepareUnsourcemappedStackTrace\n\n  // @ts-expect-error -- TODO upstream types\n  // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n  Error.prototype[inspectSymbol] = function (\n    depth: number,\n    inspectOptions: util.InspectOptions,\n    inspect: typeof util.inspect\n  ): string {\n    // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n    return workUnitAsyncStorage.exit(() => {\n      // Create a new Error object with the source mapping applied and then use native\n      // Node.js formatting on the result.\n      const newError =\n        this.cause !== undefined\n          ? // Setting an undefined `cause` would print `[cause]: undefined`\n            new Error(this.message, { cause: this.cause })\n          : new Error(this.message)\n\n      // TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name\n      newError.stack = parseAndSourceMap(this)\n\n      for (const key in this) {\n        if (!Object.prototype.hasOwnProperty.call(newError, key)) {\n          // @ts-expect-error -- We're copying all enumerable properties.\n          // So they definitely exist on `this` and obviously have no type on `newError` (yet)\n          newError[key] = this[key]\n        }\n      }\n\n      const originalCustomInspect = (newError as any)[inspectSymbol]\n      // Prevent infinite recursion.\n      // { customInspect: false } would result in `error.cause` not using our inspect.\n      Object.defineProperty(newError, inspectSymbol, {\n        value: undefined,\n        enumerable: false,\n        writable: true,\n      })\n      try {\n        return inspect(newError, {\n          ...inspectOptions,\n          depth:\n            (inspectOptions.depth ??\n              // Default in Node.js\n              2) - depth,\n        })\n      } finally {\n        ;(newError as any)[inspectSymbol] = originalCustomInspect\n      }\n    })\n  }\n}\n"],"names":["patchErrorInspect","inspectSymbol","Symbol","for","frameToString","frame","sourceLocation","lineNumber","column","filePath","file","startsWith","URL","canParse","path","relative","process","cwd","url","fileURLToPath","methodName","computeErrorName","error","name","prepareUnsourcemappedStackTrace","structuredStackTrace","message","stack","i","length","toString","shouldIgnoreListByDefault","getSourcemappedFrameIfPossible","sourceMapCache","rawSourceMap","sourceMapCacheEntry","get","sourceMap","undefined","moduleSourceMap","findSourceMap","payload","SyncSourceMapConsumer","set","map","raw","sourcePosition","originalPositionFor","line","source","sourceContent","sourceContentFor","sourceIndex","sources","indexOf","ignored","ignoreList","includes","originalFrame","replace","arguments","codeFrame","env","NODE_ENV","getOriginalCodeFrame","code","parseAndSourceMap","unparsedStack","String","errorName","idx","lastIndexOf","slice","unsourcemappedStack","parseStack","Map","sourceMappedStack","sourceFrameDEV","sourcemappedFrame","Error","prepareStackTrace","prototype","depth","inspectOptions","inspect","workUnitAsyncStorage","exit","newError","cause","key","Object","hasOwnProperty","call","originalCustomInspect","defineProperty","value","enumerable","writable"],"mappings":"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"}