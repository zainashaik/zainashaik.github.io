{"version":3,"sources":["../../../src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task.catch((error) => this.reportTaskError(error)))\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) {\n      throw new InvariantError(\n        'Missing workUnitStore in AfterContext.addCallback'\n      )\n    }\n    this.workUnitStores.add(workUnitStore)\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await callback()\n      } catch (error) {\n        this.reportTaskError(error)\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      'An error occurred in a function passed to `unstable_after()`:',\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `unstable_after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","Promise","resolve","runCallbacks","size","phase","workStore","start","onIdle","console","handlerError","cause"],"mappings":"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"}