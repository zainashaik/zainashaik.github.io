{"version":3,"sources":["../../../src/server/resume-data-cache/resume-data-cache.ts"],"sourcesContent":["import {\n  type UseCacheCacheStore,\n  type FetchCacheStore,\n  stringifyFetchCacheStore,\n  stringifyUseCacheCacheStore,\n  parseUseCacheCacheStore,\n  parseFetchCacheStore,\n} from './cache-store'\n\n/**\n * An immutable version of the resume data cache used during rendering.\n * This cache is read-only and cannot be modified once created.\n */\nexport interface RenderResumeDataCache {\n  /**\n   * A read-only Map store for values cached by the 'use cache' React hook.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly cache: Omit<UseCacheCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for cached fetch responses.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly fetch: Omit<FetchCacheStore, 'set'>\n}\n\n/**\n * A mutable version of the resume data cache used during pre-rendering.\n * This cache allows both reading and writing of cached values.\n */\nexport interface PrerenderResumeDataCache {\n  /**\n   * A mutable Map store for values cached by the 'use cache' React hook.\n   * Supports both get and set operations to build the cache during pre-rendering.\n   */\n  readonly cache: UseCacheCacheStore\n\n  /**\n   * A mutable Map store for cached fetch responses.\n   * Supports both get and set operations to build the cache during pre-rendering.\n   */\n  readonly fetch: FetchCacheStore\n}\n\ntype ResumeStoreSerialized = {\n  store: {\n    cache: {\n      [key: string]: any\n    }\n    fetch: {\n      [key: string]: any\n    }\n  }\n}\n\n/**\n * Serializes a resume data cache into a JSON string for storage or transmission.\n * Handles both 'use cache' values and fetch responses.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or 'null' if empty\n */\nexport async function stringifyResumeDataCache(\n  resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n): Promise<string> {\n  if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n    return 'null'\n  }\n\n  const json: ResumeStoreSerialized = {\n    store: {\n      fetch: Object.fromEntries(\n        stringifyFetchCacheStore(resumeDataCache.fetch.entries())\n      ),\n      cache: Object.fromEntries(\n        await stringifyUseCacheCacheStore(resumeDataCache.cache.entries())\n      ),\n    },\n  }\n\n  return JSON.stringify(json)\n}\n\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */\nexport function createPrerenderResumeDataCache(): PrerenderResumeDataCache {\n  return {\n    cache: new Map(),\n    fetch: new Map(),\n  }\n}\n\n/**\n * Creates an immutable render resume data cache from either:\n * 1. An existing prerender cache instance\n * 2. A serialized cache string\n *\n * @param prerenderResumeDataCache - A PrerenderResumeDataCache instance to convert to immutable\n * @param persistedCache - A serialized cache string to parse\n * @returns An immutable RenderResumeDataCache instance\n */\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  persistedCache: string\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCacheOrPersistedCache: PrerenderResumeDataCache | string\n): RenderResumeDataCache {\n  if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n    // If the cache is already a prerender cache, we can return it directly,\n    // we're just performing a type change.\n    return prerenderResumeDataCacheOrPersistedCache\n  }\n\n  if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n    return {\n      cache: new Map(),\n      fetch: new Map(),\n    }\n  }\n\n  const json: ResumeStoreSerialized = JSON.parse(\n    prerenderResumeDataCacheOrPersistedCache\n  )\n  return {\n    cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n    fetch: parseFetchCacheStore(Object.entries(json.store.fetch)),\n  }\n}\n"],"names":["stringifyFetchCacheStore","stringifyUseCacheCacheStore","parseUseCacheCacheStore","parseFetchCacheStore","stringifyResumeDataCache","resumeDataCache","fetch","size","cache","json","store","Object","fromEntries","entries","JSON","stringify","createPrerenderResumeDataCache","Map","createRenderResumeDataCache","prerenderResumeDataCacheOrPersistedCache","parse"],"mappings":"AAAA,SAGEA,wBAAwB,EACxBC,2BAA2B,EAC3BC,uBAAuB,EACvBC,oBAAoB,QACf,gBAAe;AAiDtB;;;;;;CAMC,GACD,OAAO,eAAeC,yBACpBC,eAAiE;IAEjE,IAAIA,gBAAgBC,KAAK,CAACC,IAAI,KAAK,KAAKF,gBAAgBG,KAAK,CAACD,IAAI,KAAK,GAAG;QACxE,OAAO;IACT;IAEA,MAAME,OAA8B;QAClCC,OAAO;YACLJ,OAAOK,OAAOC,WAAW,CACvBZ,yBAAyBK,gBAAgBC,KAAK,CAACO,OAAO;YAExDL,OAAOG,OAAOC,WAAW,CACvB,MAAMX,4BAA4BI,gBAAgBG,KAAK,CAACK,OAAO;QAEnE;IACF;IAEA,OAAOC,KAAKC,SAAS,CAACN;AACxB;AAEA;;;;;;CAMC,GACD,OAAO,SAASO;IACd,OAAO;QACLR,OAAO,IAAIS;QACXX,OAAO,IAAIW;IACb;AACF;AAiBA,OAAO,SAASC,4BACdC,wCAA2E;IAE3E,IAAI,OAAOA,6CAA6C,UAAU;QAChE,wEAAwE;QACxE,uCAAuC;QACvC,OAAOA;IACT;IAEA,IAAIA,6CAA6C,QAAQ;QACvD,OAAO;YACLX,OAAO,IAAIS;YACXX,OAAO,IAAIW;QACb;IACF;IAEA,MAAMR,OAA8BK,KAAKM,KAAK,CAC5CD;IAEF,OAAO;QACLX,OAAON,wBAAwBS,OAAOE,OAAO,CAACJ,KAAKC,KAAK,CAACF,KAAK;QAC9DF,OAAOH,qBAAqBQ,OAAOE,OAAO,CAACJ,KAAKC,KAAK,CAACJ,KAAK;IAC7D;AACF"}