{"version":3,"sources":["../../../src/server/request/connection.ts"],"sourcesContent":["import { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\n\n/**\n * This function allows you to indicate that you require an actual user Request before continuing.\n *\n * During prerendering it will never resolve and during rendering it resolves immediately.\n */\nexport function connection(): Promise<void> {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      return Promise.resolve(undefined)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      } else if (workUnitStore.phase === 'after') {\n        throw new Error(\n          `Route ${workStore.route} used \"connection\" inside \"unstable_after(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \"unstable_after(...)\" executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/unstable_after`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We return a promise that never resolves to allow the prender to stall at this point\n        return makeHangingPromise(workUnitStore.renderSignal, '`connection()`')\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We use React's postpone API to interrupt rendering here to create a dynamic hole\n        postponeWithTracking(\n          workStore.route,\n          'connection',\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We throw an error here to interrupt prerendering to mark the route as dynamic\n        throwToInterruptStaticGeneration('connection', workStore, workUnitStore)\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using headers inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  return Promise.resolve(undefined)\n}\n"],"names":["workAsyncStorage","workUnitAsyncStorage","postponeWithTracking","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","StaticGenBailoutError","makeHangingPromise","connection","workStore","getStore","workUnitStore","forceStatic","Promise","resolve","undefined","type","Error","route","phase","dynamicShouldError","renderSignal","dynamicTracking"],"mappings":"AAAA,SAASA,gBAAgB,QAAQ,4CAA2C;AAC5E,SAASC,oBAAoB,QAAQ,iDAAgD;AACrF,SACEC,oBAAoB,EACpBC,gCAAgC,EAChCC,+BAA+B,QAC1B,kCAAiC;AACxC,SAASC,qBAAqB,QAAQ,oDAAmD;AACzF,SAASC,kBAAkB,QAAQ,6BAA4B;AAE/D;;;;CAIC,GACD,OAAO,SAASC;IACd,MAAMC,YAAYR,iBAAiBS,QAAQ;IAC3C,MAAMC,gBAAgBT,qBAAqBQ,QAAQ;IAEnD,IAAID,WAAW;QACb,IAAIA,UAAUG,WAAW,EAAE;YACzB,qFAAqF;YACrF,kCAAkC;YAClC,OAAOC,QAAQC,OAAO,CAACC;QACzB;QAEA,IAAIJ,eAAe;YACjB,IAAIA,cAAcK,IAAI,KAAK,SAAS;gBAClC,MAAM,IAAIC,MACR,CAAC,MAAM,EAAER,UAAUS,KAAK,CAAC,iVAAiV,CAAC;YAE/W,OAAO,IAAIP,cAAcK,IAAI,KAAK,kBAAkB;gBAClD,MAAM,IAAIC,MACR,CAAC,MAAM,EAAER,UAAUS,KAAK,CAAC,0XAA0X,CAAC;YAExZ,OAAO,IAAIP,cAAcQ,KAAK,KAAK,SAAS;gBAC1C,MAAM,IAAIF,MACR,CAAC,MAAM,EAAER,UAAUS,KAAK,CAAC,wWAAwW,CAAC;YAEtY;QACF;QACA,IAAIT,UAAUW,kBAAkB,EAAE;YAChC,MAAM,IAAId,sBACR,CAAC,MAAM,EAAEG,UAAUS,KAAK,CAAC,oNAAoN,CAAC;QAElP;QAEA,IAAIP,eAAe;YACjB,IAAIA,cAAcK,IAAI,KAAK,aAAa;gBACtC,sBAAsB;gBACtB,sFAAsF;gBACtF,OAAOT,mBAAmBI,cAAcU,YAAY,EAAE;YACxD,OAAO,IAAIV,cAAcK,IAAI,KAAK,iBAAiB;gBACjD,+BAA+B;gBAC/B,mFAAmF;gBACnFb,qBACEM,UAAUS,KAAK,EACf,cACAP,cAAcW,eAAe;YAEjC,OAAO,IAAIX,cAAcK,IAAI,KAAK,oBAAoB;gBACpD,mBAAmB;gBACnB,gFAAgF;gBAChFZ,iCAAiC,cAAcK,WAAWE;YAC5D;QACF;QACA,iFAAiF;QACjF,yFAAyF;QACzFN,gCAAgCI,WAAWE;IAC7C;IAEA,OAAOE,QAAQC,OAAO,CAACC;AACzB"}