{"version":3,"sources":["../../../src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  Segment,\n} from './types'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { renderToReadableStream } from 'react-server-dom-webpack/server.edge'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { UNDERSCORE_NOT_FOUND_ROUTE } from '../../api/constants'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\ntype RootTreePrefetch = {\n  tree: TreePrefetch\n  staleTime: number\n}\n\ntype TreePrefetch = {\n  // The key to use when requesting the data for this segment (analogous to a\n  // URL). Also used as a cache key, although the server may specify a different\n  // cache key when it responds (analagous to a Vary header), like to omit\n  // params if they aren't used to compute the response. (This part not\n  // yet implemented)\n  key: string\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  extra: [segment: Segment, isRootLayout: boolean]\n}\n\ntype SegmentPrefetch = {\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData\n\n  // Access tokens for the child segments.\n  slots: null | {\n    [parallelRouteKey: string]: string\n  }\n}\n\nexport async function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any\n): Promise<Map<string, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<string, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[string, Buffer]>> = []\n  const treeStream = await renderToReadableStream(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      fullPageDataBuffer={fullPageDataBuffer}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n    />,\n    clientModules,\n    {\n      // Unlike when rendering the segment streams, we do not pass an abort\n      // controller here. There's nothing dynamic in the prefetch metadata; we\n      // will always render the result. We do still have to account for hanging\n      // promises, but we use a different strategy. See PrefetchTreeData.\n      onError() {\n        // Ignore any errors. These would have already been reported when\n        // we created the full page data.\n      },\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree', treeBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  fullPageDataBuffer,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n}: {\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[string, Buffer]>>\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    streamFromBuffer(fullPageDataBuffer),\n    {\n      serverConsumerManifest,\n    }\n  )\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = await collectSegmentDataImpl(\n    flightRouterState,\n    seedData,\n    fullPageDataBuffer,\n    clientModules,\n    serverConsumerManifest,\n    '',\n    '',\n    segmentTasks\n  )\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    tree,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nasync function collectSegmentDataImpl(\n  route: FlightRouterState,\n  seedData: CacheNodeSeedData,\n  fullPageDataBuffer: Buffer,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  segmentPathStr: string,\n  accessToken: string,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): Promise<TreePrefetch> {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  // Access tokens for the child segments. Sent as part of layout's data. Null\n  // if there are no children.\n  let childAccessTokens: { [parallelRouteKey: string]: string } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData[2]\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData = seedDataChildren[parallelRouteKey]\n    if (!childSeedData) {\n      // No corresponding seed data for this segment.\n      continue\n    }\n    const childSegmentPathStr =\n      segmentPathStr +\n      '/' +\n      encodeChildSegmentAsFilesystemSafePathname(parallelRouteKey, childSegment)\n\n    // Create an access token for each child slot.\n    const childAccessToken = await createSegmentAccessToken(\n      segmentPathStr,\n      parallelRouteKey\n    )\n    const childTree = await collectSegmentDataImpl(\n      childRoute,\n      seedData,\n      fullPageDataBuffer,\n      clientModules,\n      serverConsumerManifest,\n      childSegmentPathStr,\n      childAccessToken,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n\n    if (childAccessTokens === null) {\n      childAccessTokens = {}\n    }\n    childAccessTokens[parallelRouteKey] = childAccessToken\n  }\n\n  // Spawn a task to write the segment data to a new Flight stream.\n  segmentTasks.push(\n    // Since we're already in the middle of a render, wait until after the\n    // current task to escape the current rendering context.\n    waitAtLeastOneReactRenderTask().then(() =>\n      renderSegmentPrefetch(\n        seedData,\n        segmentPathStr,\n        accessToken,\n        childAccessTokens,\n        clientModules\n      )\n    )\n  )\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  const segment = route[0]\n  const isRootLayout = route[4]\n  return {\n    key: segmentPathStr === '' ? '/' : segmentPathStr,\n    slots: slotMetadata,\n    extra: [segment, isRootLayout === true],\n  }\n}\n\nasync function renderSegmentPrefetch(\n  seedData: CacheNodeSeedData,\n  segmentPathStr: string,\n  accessToken: string,\n  childAccessTokens: { [parallelRouteKey: string]: string } | null,\n  clientModules: ManifestNode\n): Promise<[string, Buffer]> {\n  // Render the segment data to a stream.\n  // In the future, this is where we can include additional metadata, like the\n  // stale time and cache tags.\n  const rsc = seedData[1]\n  const loading = seedData[3]\n  const segmentPrefetch: SegmentPrefetch = {\n    rsc,\n    loading,\n    slots: childAccessTokens,\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const segmentStream = await renderToReadableStream(\n    segmentPrefetch,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError() {\n        // Ignore any errors. These would have already been reported when\n        // we created the full page data.\n      },\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  // Add the buffer to the result map.\n  if (segmentPathStr === '') {\n    return ['/', segmentBuffer]\n  } else {\n    // The access token is appended to the end of the segment name. To request\n    // a segment, the client sends a header like:\n    //\n    //   Next-Router-Segment-Prefetch: /path/to/segment.accesstoken\n    //\n    // The segment path is provided by the tree prefetch, and the access\n    // token is provided in the parent layout's data.\n    const fullPath = `${segmentPathStr}.${accessToken}`\n    return [fullPath, segmentBuffer]\n  }\n}\n\n// TODO: Consider updating or unifying this encoding logic for segments with\n// createRouterCacheKey on the client, perhaps by including it as part of\n// the FlightRouterState. Theoretically the client should never have to do its\n// own encoding of segment keys; it can pass back whatever the server gave it.\nfunction encodeChildSegmentAsFilesystemSafePathname(\n  parallelRouteKey: string,\n  segment: Segment\n): string {\n  // Encode a child segment and its corresponding parallel route key to a\n  // filesystem-safe pathname. The format is internal-only and can be somewhat\n  // arbitrary as long as there are no collisions, because these will be used\n  // as filenames during build and in the incremental cache. They will also\n  // be sent by the client to request the corresponding segment, but they\n  // do not need to be decodable. The server will merely look for a matching\n  // file in the cache.\n  //\n  // For ease of debugging, the format looks roughly similar to the App Router\n  // convention for defining routes in the source, but again the exact format is\n  // not important as long as it's consistent between the client and server and\n  // meets the above requirements.\n  //\n  // TODO: If the segment did not read from params, then we can omit the\n  // params from the cache key. Need to track this during the prerender somehow.\n  let safeSegmentValue\n  if (typeof segment === 'string') {\n    safeSegmentValue = encodeParamValue(segment)\n  } else {\n    // Parameterized segments.\n    const [paramName, paramValue, paramType] = segment\n    let paramPrefix\n    switch (paramType) {\n      case 'c':\n      case 'ci':\n        paramPrefix = `[...${paramName}]`\n        break\n      case 'oc':\n        paramPrefix = `[[...${paramName}]]`\n        break\n      case 'd':\n      case 'di':\n        paramPrefix = `[${paramName}]`\n        break\n      default:\n        throw new Error('Unknown dynamic param type')\n    }\n    safeSegmentValue = `${paramPrefix}-${encodeParamValue(paramValue)}`\n  }\n  let result\n  if (parallelRouteKey === 'children') {\n    // Omit the parallel route key for children, since this is the most\n    // common case. Saves some bytes.\n    result = `${safeSegmentValue}`\n  } else {\n    result = `@${parallelRouteKey}/${safeSegmentValue}`\n  }\n  return result\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeParamValue(segment: string): string {\n  if (segment === UNDERSCORE_NOT_FOUND_ROUTE) {\n    // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\". But\n    // params typically don't include the leading slash. We should use a\n    // different encoding to avoid this special case.\n    return '_not-found'\n  }\n  if (simpleParamValueRegex.test(segment)) {\n    return segment\n  }\n  // If there are any unsafe characters, base64url-encode the entire segment.\n  // We also add a $ prefix so it doesn't collide with the simple case.\n  return '$' + Buffer.from(segment, 'utf-8').toString('base64url')\n}\n\nasync function createSegmentAccessToken(\n  parentSegmentPathStr: string,\n  parallelRouteKey: string\n): Promise<string> {\n  // Create an access token that the client passes when requesting a segment.\n  // The token is sent to the client as part of the parent layout's data.\n  //\n  // The token is hash of the parent segment path and the parallel route key. A\n  // subtle detail here is that it does *not* include the value of the segment\n  // itself â€” a shared layout must produce the same access tokens for its\n  // children regardless of their segment values, so that the client only has to\n  // fetch the layout once.\n  //\n  // TODO: Because this only affects prefetches, this doesn't need to be secure.\n  // It's just for obfuscation. But eventually we will use this technique when\n  // performing dynamic navigations, to support auth checks in a layout that\n  // conditionally renders its slots. At that point we'll need to add a salt.\n\n  // Encode the inputs as Uint8Array\n  const encoder = new TextEncoder()\n  const data = encoder.encode(parentSegmentPathStr + parallelRouteKey)\n\n  // Use the Web Crypto API to generate a SHA-256 hash.\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data)\n\n  // Convert the ArrayBuffer to a hex string\n  const hashArray = new Uint8Array(hashBuffer)\n  const hashHex = Array.from(hashArray)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n\n  return hashHex\n}\n"],"names":["createFromReadableStream","renderToReadableStream","streamFromBuffer","streamToBuffer","UNDERSCORE_NOT_FOUND_ROUTE","waitAtLeastOneReactRenderTask","collectSegmentData","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","resultMap","Map","segmentTasks","treeStream","PrefetchTreeData","onError","treeBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","flightDataPaths","f","length","console","error","flightRouterState","seedData","tree","collectSegmentDataImpl","treePrefetch","route","segmentPathStr","accessToken","slotMetadata","childAccessTokens","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childSegmentPathStr","encodeChildSegmentAsFilesystemSafePathname","childAccessToken","createSegmentAccessToken","childTree","push","then","renderSegmentPrefetch","segment","isRootLayout","key","slots","extra","rsc","loading","segmentPrefetch","abortController","AbortController","abort","segmentStream","signal","segmentBuffer","fullPath","safeSegmentValue","encodeParamValue","paramName","paramValue","paramType","paramPrefix","Error","result","simpleParamValueRegex","test","Buffer","from","toString","parentSegmentPathStr","encoder","TextEncoder","data","encode","hashBuffer","crypto","subtle","digest","hashArray","Uint8Array","hashHex","Array","map","byte","padStart","join"],"mappings":"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"}