{"version":3,"sources":["../../src/server/patch-error-inspect.ts"],"sourcesContent":["import { findSourceMap, type SourceMapPayload } from 'module'\nimport * as path from 'path'\nimport * as url from 'url'\nimport type * as util from 'util'\nimport { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map'\nimport type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport { parseStack } from '../client/components/react-dev-overlay/server/middleware'\nimport { getOriginalCodeFrame } from '../client/components/react-dev-overlay/server/shared'\nimport { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external'\n\ninterface ModernRawSourceMap extends SourceMapPayload {\n  ignoreList?: number[]\n}\n\ninterface IgnoreableStackFrame extends StackFrame {\n  ignored: boolean\n}\n\ntype SourceMapCache = Map<\n  string,\n  { map: SyncSourceMapConsumer; raw: ModernRawSourceMap }\n>\n\n// TODO: Implement for Edge runtime\nconst inspectSymbol = Symbol.for('nodejs.util.inspect.custom')\n\nfunction frameToString(frame: StackFrame): string {\n  let sourceLocation = frame.lineNumber !== null ? `:${frame.lineNumber}` : ''\n  if (frame.column !== null && sourceLocation !== '') {\n    sourceLocation += `:${frame.column}`\n  }\n\n  const filePath =\n    frame.file !== null &&\n    frame.file.startsWith('file://') &&\n    URL.canParse(frame.file)\n      ? // If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.\n        // In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.\n        // There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted\n        // since relative to cwd is both the shortest and snappiest.\n        path.relative(process.cwd(), url.fileURLToPath(frame.file))\n      : frame.file\n\n  return frame.methodName\n    ? `    at ${frame.methodName} (${filePath}${sourceLocation})`\n    : `    at ${filePath}${frame.lineNumber}:${frame.column}`\n}\n\nfunction computeErrorName(error: Error): string {\n  // TODO: Node.js seems to use a different algorithm\n  // class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`\n  // in the stack i.e. seems like under certain conditions it favors the constructor name.\n  return error.name || 'Error'\n}\n\nfunction prepareUnsourcemappedStackTrace(\n  error: Error,\n  structuredStackTrace: any[]\n): string {\n  const name = computeErrorName(error)\n  const message = error.message || ''\n  let stack = name + ': ' + message\n  for (let i = 0; i < structuredStackTrace.length; i++) {\n    stack += '\\n    at ' + structuredStackTrace[i].toString()\n  }\n  return stack\n}\n\nfunction shouldIgnoreListByDefault(file: string): boolean {\n  return file.startsWith('node:')\n}\n\nfunction getSourcemappedFrameIfPossible(\n  frame: StackFrame,\n  sourceMapCache: SourceMapCache\n): {\n  stack: IgnoreableStackFrame\n  // DEV only\n  code: string | null\n} | null {\n  if (frame.file === null) {\n    return null\n  }\n\n  const sourceMapCacheEntry = sourceMapCache.get(frame.file)\n  let sourceMap: SyncSourceMapConsumer\n  let rawSourceMap: ModernRawSourceMap\n  if (sourceMapCacheEntry === undefined) {\n    const moduleSourceMap = findSourceMap(frame.file)\n    if (moduleSourceMap === undefined) {\n      return null\n    }\n    rawSourceMap = moduleSourceMap.payload\n    sourceMap = new SyncSourceMapConsumer(\n      // @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string\n      rawSourceMap\n    )\n    sourceMapCache.set(frame.file, {\n      map: sourceMap,\n      raw: rawSourceMap,\n    })\n  } else {\n    sourceMap = sourceMapCacheEntry.map\n    rawSourceMap = sourceMapCacheEntry.raw\n  }\n\n  const sourcePosition = sourceMap.originalPositionFor({\n    column: frame.column ?? 0,\n    line: frame.lineNumber ?? 1,\n  })\n\n  if (sourcePosition.source === null) {\n    return null\n  }\n\n  const sourceContent: string | null =\n    sourceMap.sourceContentFor(\n      sourcePosition.source,\n      /* returnNullOnMissing */ true\n    ) ?? null\n\n  // TODO: O(n^2). Consider moving `ignoreList` into a Set\n  const sourceIndex = rawSourceMap.sources.indexOf(sourcePosition.source)\n  const ignored = rawSourceMap.ignoreList?.includes(sourceIndex) ?? false\n\n  const originalFrame: IgnoreableStackFrame = {\n    methodName:\n      sourcePosition.name ||\n      // default is not a valid identifier in JS so webpack uses a custom variable when it's an unnamed default export\n      // Resolve it back to `default` for the method name if the source position didn't have the method.\n      frame.methodName\n        ?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')\n        ?.replace('__webpack_exports__.', ''),\n    column: sourcePosition.column,\n    file: sourcePosition.source,\n    lineNumber: sourcePosition.line,\n    // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n    arguments: [],\n    ignored,\n  }\n\n  const codeFrame =\n    process.env.NODE_ENV !== 'production'\n      ? getOriginalCodeFrame(originalFrame, sourceContent)\n      : null\n\n  return {\n    stack: originalFrame,\n    code: codeFrame,\n  }\n}\n\nfunction parseAndSourceMap(error: Error): string {\n  // We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.\n  let unparsedStack = String(error.stack)\n  // We could just read it from `error.stack`.\n  // This works around cases where a 3rd party `Error.prepareStackTrace` implementation\n  // doesn't implement the name computation correctly.\n  const errorName = computeErrorName(error)\n\n  let idx = unparsedStack.indexOf('react-stack-bottom-frame')\n  if (idx !== -1) {\n    idx = unparsedStack.lastIndexOf('\\n', idx)\n  }\n  if (idx !== -1) {\n    // Cut off everything after the bottom frame since it'll be React internals.\n    unparsedStack = unparsedStack.slice(0, idx)\n  }\n\n  const unsourcemappedStack = parseStack(unparsedStack)\n  const sourceMapCache: SourceMapCache = new Map()\n\n  let sourceMappedStack = ''\n  let sourceFrameDEV: null | string = null\n  for (const frame of unsourcemappedStack) {\n    if (frame.file === null) {\n      sourceMappedStack += '\\n' + frameToString(frame)\n    } else if (!shouldIgnoreListByDefault(frame.file)) {\n      const sourcemappedFrame = getSourcemappedFrameIfPossible(\n        frame,\n        sourceMapCache\n      )\n\n      if (sourcemappedFrame === null) {\n        sourceMappedStack += '\\n' + frameToString(frame)\n      } else {\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          sourcemappedFrame.code !== null &&\n          sourceFrameDEV === null &&\n          // TODO: Is this the right choice?\n          !sourcemappedFrame.stack.ignored\n        ) {\n          sourceFrameDEV = sourcemappedFrame.code\n        }\n        if (!sourcemappedFrame.stack.ignored) {\n          // TODO: Consider what happens if every frame is ignore listed.\n          sourceMappedStack += '\\n' + frameToString(sourcemappedFrame.stack)\n        }\n      }\n    }\n  }\n\n  return (\n    errorName +\n    ': ' +\n    error.message +\n    sourceMappedStack +\n    (sourceFrameDEV !== null ? '\\n' + sourceFrameDEV : '')\n  )\n}\n\nexport function patchErrorInspect() {\n  Error.prepareStackTrace = prepareUnsourcemappedStackTrace\n\n  // @ts-expect-error -- TODO upstream types\n  // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n  Error.prototype[inspectSymbol] = function (\n    depth: number,\n    inspectOptions: util.InspectOptions,\n    inspect: typeof util.inspect\n  ): string {\n    // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n    return workUnitAsyncStorage.exit(() => {\n      // Create a new Error object with the source mapping applied and then use native\n      // Node.js formatting on the result.\n      const newError =\n        this.cause !== undefined\n          ? // Setting an undefined `cause` would print `[cause]: undefined`\n            new Error(this.message, { cause: this.cause })\n          : new Error(this.message)\n\n      // TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name\n      newError.stack = parseAndSourceMap(this)\n\n      for (const key in this) {\n        if (!Object.prototype.hasOwnProperty.call(newError, key)) {\n          // @ts-expect-error -- We're copying all enumerable properties.\n          // So they definitely exist on `this` and obviously have no type on `newError` (yet)\n          newError[key] = this[key]\n        }\n      }\n\n      const originalCustomInspect = (newError as any)[inspectSymbol]\n      // Prevent infinite recursion.\n      // { customInspect: false } would result in `error.cause` not using our inspect.\n      Object.defineProperty(newError, inspectSymbol, {\n        value: undefined,\n        enumerable: false,\n        writable: true,\n      })\n      try {\n        return inspect(newError, {\n          ...inspectOptions,\n          depth:\n            (inspectOptions.depth ??\n              // Default in Node.js\n              2) - depth,\n        })\n      } finally {\n        ;(newError as any)[inspectSymbol] = originalCustomInspect\n      }\n    })\n  }\n}\n"],"names":["findSourceMap","path","url","SourceMapConsumer","SyncSourceMapConsumer","parseStack","getOriginalCodeFrame","workUnitAsyncStorage","inspectSymbol","Symbol","for","frameToString","frame","sourceLocation","lineNumber","column","filePath","file","startsWith","URL","canParse","relative","process","cwd","fileURLToPath","methodName","computeErrorName","error","name","prepareUnsourcemappedStackTrace","structuredStackTrace","message","stack","i","length","toString","shouldIgnoreListByDefault","getSourcemappedFrameIfPossible","sourceMapCache","rawSourceMap","sourceMapCacheEntry","get","sourceMap","undefined","moduleSourceMap","payload","set","map","raw","sourcePosition","originalPositionFor","line","source","sourceContent","sourceContentFor","sourceIndex","sources","indexOf","ignored","ignoreList","includes","originalFrame","replace","arguments","codeFrame","env","NODE_ENV","code","parseAndSourceMap","unparsedStack","String","errorName","idx","lastIndexOf","slice","unsourcemappedStack","Map","sourceMappedStack","sourceFrameDEV","sourcemappedFrame","patchErrorInspect","Error","prepareStackTrace","prototype","depth","inspectOptions","inspect","exit","newError","cause","key","Object","hasOwnProperty","call","originalCustomInspect","defineProperty","value","enumerable","writable"],"mappings":"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"}